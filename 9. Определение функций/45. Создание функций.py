# 45 Создание (определение) функций

# Создадим нашу первую функцию. Ее задача — вывести на экран приветствие: Hello, Hexlet!

# Определение функции
# Определение не вызывает и не выполняет функцию
# Мы лишь говорим, что теперь такая функция существует
def show_greeting():
    # Внутри тела отступ четыре пробела
    text = 'Hello, Hexlet!'
    print(text)

# Вызов функции
show_greeting()  # => 'Hello, Hexlet!'


# Тело функции может быть пустым, тогда внутри него используется ключевое слово pass:
# Минимальное определение функции
def noop():
    pass

noop()


# Теперь изменим функцию greeting() так, чтобы она возвращала данные. Для этого выполним возврат вместо печати на экран:
# return — это инструкция. Она берет записанное справа выражение и отдает его тому коду, который вызвал метод. Здесь выполнение функции завершается. Любой код после return не выполняется.
def greeting():
    return 'Hello, Hexlet!'
    print('Я никогда не выполнюсь')

gr = greeting()
print(gr.upper())

def say_hurray_three_times():
    res = ('hurray! ' * 3).strip()
    return res

hurray = say_hurray_three_times()
print(hurray) # => hurray! hurray! hurray!


# 47 Параметры функций

# реализовать функцию get_last_char(), которая возвращает последний символ в строке, переданной ему на вход как параметр.
def get_last_char(param1):
    return param1[-1]

print(get_last_char("Hexlet"))

# несколько параметров
def truncate(text, length):
    result = f"{text[0:length]}..."
    return result

text = 'it works!'
print(truncate(text, 4)) # 'it w...'


# 48 Необязательные параметры функций

# У значений по умолчанию есть одно ограничение. Они должны идти в самом конце списка параметров.
# С точки зрения синтаксиса, невозможно создать функцию, у которой после необязательного параметра идет обязательный:

def f(x, a=5, b=10, c=100):
    return x + a - b + c

# Реализуйте функцию get_hidden_card(), который принимает на вход номер кредитки (состоящий из 16 цифр) в виде строки и возвращает его скрытую версию
# Количество звездочек регулируется вторым, необязательным, параметром
def get_hidden_card(card_number, stars_count = 4) :
    result = f'{"*" * stars_count}{card_number[-4:]}'
    return result

print(get_hidden_card('65418916514'))
print(get_hidden_card('65418916514',2))


# 49 Именованные аргументы

# Аргументы — это данные, которые передаются в вызов функции. Они бывают двух типов:
# Первый тип — позиционные аргументы. Они передаются в том же порядке, в котором определены параметры функции:
truncate('My Text', 3)

# Второй тип — именованные аргументы. Они передаются не просто как значения, а как пара «имя=значение». Поэтому их можно передавать в любом порядке:
truncate(length=3, text='My Text')


# Последнее полезно, если у функции много необязательных параметров. Посмотрим на примере:
def f(a=1, b=2, c=None, d=4):
    print(a, b, c, d)

# Нужно передать только d, но приходится передавать все
f(1, 2, 3, 8)

# Именованные аргументы позволяют передавать только d
# Для остальных аргументов используются значения по умолчанию
f(d=8)

# Именованные аргументы можно передавать одновременно с позиционными. Тогда позиционные должны идти в самом начале:
# # Передаем только a (позиционно) и d (как именованный)
f(3, d=15)


def trim_and_repeat(text, offset=0, repetitions=1) :
    cut_text = text[offset:]
    result = cut_text * repetitions
    return result
# или так  return f'{text[offset:] * repetitions}'

text = 'python'
print(trim_and_repeat(text, offset=3, repetitions=2)) # => honhon
print(trim_and_repeat(text, repetitions=3)) # => pythonpythonpython
print(trim_and_repeat(text)) # => python



# 50 Аннотации типов — это возможность указать типы параметров и возвращаемое значение у функции в Python.
# Это не является обязательным требованием языка, но может помочь программистам в дальнейшей разработке, улучшить читаемость кода и повысить его надежность.

# Здесь мы указали, что аргументы first и second должны быть строкового типа (str).
# Возвращаемое значение тоже будет строковым. Когда мы будем использовать эту функцию в коде, нам будет проще понять, какие типы аргументов можно передавать и какой тип возвращаемого значения ожидается.
def concat(first: str, second: str) -> str:
    return first + second


# Аннотации типов также могут быть использованы для определения типов переменных внутри функции. Например:
def double(n: int) -> int:
    result: int = n * 2
    return result


def word_multiply(text: str, number: int) -> str:
    return text * number

text = 'python2'
print(word_multiply(text, 2)) # => pythonpython
print(word_multiply(text, 0)) # =>